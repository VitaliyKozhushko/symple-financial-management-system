# Тестовое задание

Разработать систему управления финансами с расширенными функциями для обработки транзакций

## Содержание
1. [Требования](#main_requirements)
2. [Стек технологий](#technology_stack)
3. [Документация по API](#doc_api)
4. [Инструкция по запуску проекта](#instruction_startup)
5. [Тестирование](#testing)
6. [Особенности](#features)

## Требования <a name="main_requirements"></a>

1.	Среда разработки: 
   - Использовать Python 3.8+. 
   - Использовать Django 3.2+ и Django REST Framework 3.12+. 
   - Использовать PostgreSQL в качестве базы данных.
2.	Модели:
   - User: Представляет пользователя с полями для имени, фамилии, email и даты регистрации. 
   - Transaction: Представляет финансовую транзакцию с полями для суммы, даты, типа (доход/расход), категории и внешним ключом на модель User.
3.	API эндпоинты:
   - Пользователи:
     - GET /users/: Список всех пользователей. 
     - POST /users/: Создание нового пользователя. 
     - GET /users/{id}/: Получение информации о конкретном пользователе по ID. 
     - PUT /users/{id}/: Обновление информации о конкретном пользователе по ID. 
     - DELETE /users/{id}/: Удаление конкретного пользователя по ID. 
   - Транзакции:
     - GET /transactions/: Список всех транзакций. 
     - POST /transactions/: Создание новой транзакции. 
     - GET /transactions/{id}/: Получение информации о конкретной транзакции по ID. 
     - PUT /transactions/{id}/: Обновление информации о конкретной транзакции по ID. 
     - DELETE /transactions/{id}/: Удаление конкретной транзакции по ID.
4.	Расширенные функции (необязательно для реализации):
   - Отслеживание бюджета: Реализовать логику для отслеживания расходов по бюджетам и оповещения пользователей, когда они приближаются к лимитам бюджета. 
   - Генерация отчетов: Реализовать функциональность для создания финансовых отчетов, суммирующих транзакции за указанный период. 
   - Экспорт данных: Предоставить эндпоинты для экспорта данных транзакций и отчетов в формате CSV.
5.	Валидация:
   - Убедиться, что email пользователя является валидным. 
   - Убедиться, что сумма транзакции является положительным числом.
   - (Необязателно) Убедиться, что дата окончания бюджета следует за датой начала.
6.	Тестирование (необязательно для реализации):
   - Написать unit-тесты для моделей. 
   - Написать интеграционные тесты для API эндпоинтов. 
   - Написать тесты для расширенных функций (отслеживание бюджета, генерация отчетов, экспорт данных).
7.	Документация:
   - (Необязательно) Предоставить документацию API с использованием Django REST Framework's browsable API или Swagger. 
   - Включить подробные инструкции по настройке и запуску проекта в файл README.md.

## Стек технологий <a name="technology_stack"></a>

- Backend: [Django](https://www.djangoproject.com/), [Django Rest Framework](https://www.django-rest-framework.org/)
- База данных: [PostgreSQL](https://www.postgresql.org/)
- Контроль версий: [Git](https://git-scm.com/), [GitHub](https://github.com/)
- Контейнеризация: [Docker](https://www.docker.com/)
- Асинхронность: [Celery](https://docs.celeryq.dev/)
- Брокер сообщений: [Redis](https://redis.io/)
- Документация: [DRF YASG](https://drf-yasg.readthedocs.io/en/stable/readme.html)

## Документация по API <a name="doc_api"></a>

- Swagger: http://localhost:8000/swagger/
- Redoc: http://localhost:8000/redoc/

## Инструкция по запуску проекта <a name="instruction_startup"></a>

1. Клонируйте репозиторий
```
git clone https://github.com/VitaliyKozhushko/symple-financial-management-system.git
```
2. Настройте .env файлы: 
   - .env - обычный запуск
   - .env.docker - запуск с помощью Docker.

3. Запустите проект:
    * (суперпользователь будет автоматически создан - login: admin, password - admin)
    ```shell
    docker compose up --build -d
    ```
4. Тестирование:
    ```shell
    docker compose exec django pytest
    ```
5. Проверка типизации, стилей кода, анализа кода (запустить команды поочередно):
    ```shell
    docker compose exec django mypy .
    docker compose exec django flake8 .
    docker compose exec django pylint .
    ```
   
## Особенности <a name="main_requirements"></a>

- JWT: исп. 32-байтовый ключ в шестнадцетиричном формате, содержащий спецсимволы
- установлен gunicorn для иммитации деплоя на продакшн
- исп. стандартная валидация email
- в swagger в модалке для авторизации ввести токен формата "Bearer [access_token]"
- в рамках данного задания предполагается, что можно редактировать как транзакции, созданные самим собой, 
  так и транзакции других пользователей
- дата для транзакции может быть как указана, так и не указана (см. validate_date_transaction)
- период формирования отчета может быть как указан, так и не указан
- способы получения отчета (можно выбрать только 1 из 2-х вариантов):
  - в виде ссылки с сохранением файла в БД
  - отправкой csv файла на email без сохранения в БД (в кач-ве email на который надо отправить файл, по умолч. берется
         email, указанный при регистрации)
- нельзя удалять пользователю самого себя
- суперпользователь в списке пользователей не выводится

- формирование отчета: 
  - в первую очередь проверяется наличие записей в БД с указанным id пользователя за указанный период
  - если записей нет, то отправляется соответствующ. сообщение и задачи по формированию отчета не запускаются
  - если записи есть, то запускается задача Celery по формированию отчета
    - задача Celery сохраняется в БД
    - изменение статуса задачи также сохраняется в БД
    - после создания файла, название файла сохраняется в таблице у соответствующей задачи
    - после запуска задачи прилетает ответ с id Celery-задачи
    - для получения информации о ходе формирования отчета, а также о получения ссылки для скачивания файла либо 
                статуса отправки на email, надо перейти по url /report/{task_id_celery}
    - для скачивания отчета перейти по сссылке, полученной в ответе при успешном формировании отчета в поле file_url
    - если файл отправлен на email, то об этом будет информация в ответе и полученное письмо по указанной почте
    
- бюджет (рейлизован самый простой вариант без учета большинства возможных кейсов):
  - у каждого пользователя может быть свой бюджет и свои категории
  - бюджет за период представлен в виде JSON структуры (более подробно в описании модели бюджета)
  - для email уведомлений исп. email, указанный при регистрации
  - создание бюджета происходит через отдельный роут
  - при получении списка бюджетов, для ускорения обработки, прилетает список с элементами, содержащий id бюджета и период действия
  - для получения подробных данных по бюджету, необходимо отправить запрос с уазанием id бюджета
  - категории берутся из модели Transaction.category (в рамках тестового задния не была реализована таблица для категорий)
  - оповещение о приближении к лимиту отправляется только 1 раз, при пересечении 90%. Если меняется лимит по бюджету, то необходимо
    в категории бюджета установить is_notified = False, date_notified = ''. Данный кейс под капотом не реализован, только
    ручками
  - валидация для бюджета:
    - дата завершения бюджета позже даты начала
    - дата начала бюджета следует за датой завершения предыдущего бюджета
    - структура бюджета (наличие необходимых полей)
  - при создании транзакции, если есть бюджет за период, в котором создается/редактируется транзакция, проверяется наличие
    лимита для категории. Если лимита нет, то улетает уведомление на email. Уведомление будет отправляться до тех пор, пока
    не будет добавлен лимит по категории
  - при любых действиях с транзакцией, проиходит изм. бюджета
